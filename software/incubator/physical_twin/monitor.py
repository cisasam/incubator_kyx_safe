#
# Incubator Model (Discrete Intensity).py
# Generated by KeYmaera X
#

from typing import Callable
import numpy as np

# Model parameters
class Params:
  def __init__(self, cAir: np.float64, cHeater: np.float64, gBox: np.float64, gHeater: np.float64, maxCurrent: np.float64, maxTemp: np.float64, minTemp: np.float64, periodTime: np.float64, tRoom: np.float64, voltage: np.float64):
    self.cAir = cAir
    self.cHeater = cHeater
    self.gBox = gBox
    self.gHeater = gHeater
    self.maxCurrent = maxCurrent
    self.maxTemp = maxTemp
    self.minTemp = minTemp
    self.periodTime = periodTime
    self.tRoom = tRoom
    self.voltage = voltage
  def __str__(self) -> str:
    return "Params(" + "cAir=" + str(self.cAir) + ", " + "cHeater=" + str(self.cHeater) + ", " + "gBox=" + str(self.gBox) + ", " + "gHeater=" + str(self.gHeater) + ", " + "maxCurrent=" + str(self.maxCurrent) + ", " + "maxTemp=" + str(self.maxTemp) + ", " + "minTemp=" + str(self.minTemp) + ", " + "periodTime=" + str(self.periodTime) + ", " + "tRoom=" + str(self.tRoom) + ", " + "voltage=" + str(self.voltage) +  ")"

# State (control choices, environment measurements etc.)
class State:
  def __init__(self, current: np.float64, t: np.float64, tBair: np.float64, tHeater: np.float64):
    self.current = current
    self.t = t
    self.tBair = tBair
    self.tHeater = tHeater
  def __str__(self) -> str:
    return "State(" + "current=" + str(self.current) + ", " + "t=" + str(self.t) + ", " + "tBair=" + str(self.tBair) + ", " + "tHeater=" + str(self.tHeater) +  ")"

# Values for resolving non-deterministic assignments in control code
class Input:
  def __init__(self):
    self
  def __str__(self) -> str:
    return "Input(" +  ")"

# Verdict identifier and value
class Verdict:
  def __init__(self, id: np.float64, val: np.float64):
    self.id = id
    self.val = val
  def __str__(self) -> str:
    return "Verdict(" + "id=" + str(self.id) + ", " + "val=" + str(self.val) +  ")"

def checkInit(init: State, params: Params) -> Verdict:
  (params.periodTime > np.float64(0.0)) and ((init.current == np.float64(0.0)) and ((init.tHeater >= init.tBair) and ((params.tRoom <= init.tBair) and ((params.gHeater > np.float64(0.0)) and ((params.gBox > np.float64(0.0)) and ((params.cAir > np.float64(0.0)) and ((params.cHeater > np.float64(0.0)) and ((params.maxCurrent > np.float64(0.0)) and ((params.tRoom > np.float64(0.0)) and ((params.voltage > np.float64(0.0)) and ((((((params.maxTemp)*((params.gHeater)+(params.gBox)))-((params.gBox)*(params.tRoom)))/(params.gHeater))-((((params.voltage)*(params.maxCurrent))*(params.periodTime))/(params.cHeater)) > ((((params.minTemp)*((params.gHeater)+(params.gBox)))-((params.gBox)*(params.tRoom)))/(params.gHeater))*((params.cHeater)/((params.cHeater)-((params.gHeater)*(params.periodTime))))) and ((init.tHeater < ((((params.maxTemp)*((params.gHeater)+(params.gBox)))-((params.gBox)*(params.tRoom)))/(params.gHeater))-((((params.voltage)*(params.maxCurrent))*(params.periodTime))/(params.cHeater))) and ((init.tHeater > ((((params.minTemp)*((params.gHeater)+(params.gBox)))-((params.gBox)*(params.tRoom)))/(params.gHeater))*((params.cHeater)/((params.cHeater)-((params.gHeater)*(params.periodTime))))) and ((init.tBair <= params.maxTemp) and ((init.tBair >= params.minTemp) and ((params.minTemp < params.maxTemp) and ((params.cHeater > (params.gHeater)*(params.periodTime)) and ((params.voltage)*(params.maxCurrent) > (((params.maxTemp)*((params.gHeater)+(params.gBox)))-((params.gBox)*(params.tRoom)))-((params.gHeater)*(params.minTemp))))))))))))))))))))




def boundaryDist(pre: State, curr: State, params: Params) -> Verdict:
  '''
  Computes distance to safety boundary on prior and current state (>=0 is safe, <0 is unsafe)
  '''
  result = Verdict((1 if ((pre.tHeater >= ((((params.minTemp)*((params.gHeater)+(params.gBox)))-((params.gBox)*(params.tRoom)))/(params.gHeater))*((params.cHeater)/((params.cHeater)-((params.gHeater)*(params.periodTime))))) and (((np.float64(0.0) <= params.periodTime) and (((((params.gHeater)*((pre.tHeater)-(pre.tBair)))-((params.gBox)*((pre.tBair)-(params.tRoom))))/(params.cAir) <= np.float64(0.0)) and ((curr.current == np.float64(0.0)) and ((curr.t == np.float64(0.0)) and ((curr.tBair == pre.tBair) and (curr.tHeater == pre.tHeater)))))) or ((np.float64(0.0) <= params.periodTime) and (((((params.gHeater)*((pre.tHeater)-(pre.tBair)))-((params.gBox)*((pre.tBair)-(params.tRoom))))/(params.cAir) >= np.float64(0.0)) and ((curr.current == np.float64(0.0)) and ((curr.t == np.float64(0.0)) and ((curr.tBair == pre.tBair) and (curr.tHeater == pre.tHeater)))))))) or ((pre.tHeater <= ((((params.maxTemp)*((params.gHeater)+(params.gBox)))-((params.gBox)*(params.tRoom)))/(params.gHeater))-((((params.voltage)*(params.maxCurrent))*(params.periodTime))/(params.cHeater))) and (((np.float64(0.0) <= params.periodTime) and (((((params.gHeater)*((pre.tHeater)-(pre.tBair)))-((params.gBox)*((pre.tBair)-(params.tRoom))))/(params.cAir) <= np.float64(0.0)) and ((curr.current == params.maxCurrent) and ((curr.t == np.float64(0.0)) and ((curr.tBair == pre.tBair) and (curr.tHeater == pre.tHeater)))))) or ((np.float64(0.0) <= params.periodTime) and (((((params.gHeater)*((pre.tHeater)-(pre.tBair)))-((params.gBox)*((pre.tBair)-(params.tRoom))))/(params.cAir) >= np.float64(0.0)) and ((curr.current == params.maxCurrent) and ((curr.t == np.float64(0.0)) and ((curr.tBair == pre.tBair) and (curr.tHeater == pre.tHeater)))))))) else -1), (1 if ((pre.tHeater >= ((((params.minTemp)*((params.gHeater)+(params.gBox)))-((params.gBox)*(params.tRoom)))/(params.gHeater))*((params.cHeater)/((params.cHeater)-((params.gHeater)*(params.periodTime))))) and (((np.float64(0.0) <= params.periodTime) and (((((params.gHeater)*((pre.tHeater)-(pre.tBair)))-((params.gBox)*((pre.tBair)-(params.tRoom))))/(params.cAir) <= np.float64(0.0)) and ((curr.current == np.float64(0.0)) and ((curr.t == np.float64(0.0)) and ((curr.tBair == pre.tBair) and (curr.tHeater == pre.tHeater)))))) or ((np.float64(0.0) <= params.periodTime) and (((((params.gHeater)*((pre.tHeater)-(pre.tBair)))-((params.gBox)*((pre.tBair)-(params.tRoom))))/(params.cAir) >= np.float64(0.0)) and ((curr.current == np.float64(0.0)) and ((curr.t == np.float64(0.0)) and ((curr.tBair == pre.tBair) and (curr.tHeater == pre.tHeater)))))))) or ((pre.tHeater <= ((((params.maxTemp)*((params.gHeater)+(params.gBox)))-((params.gBox)*(params.tRoom)))/(params.gHeater))-((((params.voltage)*(params.maxCurrent))*(params.periodTime))/(params.cHeater))) and (((np.float64(0.0) <= params.periodTime) and (((((params.gHeater)*((pre.tHeater)-(pre.tBair)))-((params.gBox)*((pre.tBair)-(params.tRoom))))/(params.cAir) <= np.float64(0.0)) and ((curr.current == params.maxCurrent) and ((curr.t == np.float64(0.0)) and ((curr.tBair == pre.tBair) and (curr.tHeater == pre.tHeater)))))) or ((np.float64(0.0) <= params.periodTime) and (((((params.gHeater)*((pre.tHeater)-(pre.tBair)))-((params.gBox)*((pre.tBair)-(params.tRoom))))/(params.cAir) >= np.float64(0.0)) and ((curr.current == params.maxCurrent) and ((curr.t == np.float64(0.0)) and ((curr.tBair == pre.tBair) and (curr.tHeater == pre.tHeater)))))))) else -1) )
  return result

def monitorSatisfied(pre: State, curr: State, params: Params) -> bool:
  '''
  Evaluates monitor condition in prior and current state
  '''
  return boundaryDist(pre,curr,params).val >= 0

def monitoredCtrl(curr: State, params: Params, inp: State,
                  ctrl: Callable[[State, State, Params], State],
                  fallback: Callable[[State, State, Params], State]) -> State:
  '''
  Run controller `ctrl` monitored, return `fallback` if `ctrl` violates monitor
  '''
  pre = curr
  post = ctrl(pre,params,inp)
  if monitorSatisfied(pre,post,params) == True:
    return post
  else:
    return fallback(pre,params,inp)
